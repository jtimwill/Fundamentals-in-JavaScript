# Fundamentals-in-JavaScript

## Outline
### Primitive Types
1. Bit manipulation
2. Type conversion
3. Type checking
4. Type sizes (bytes)

### Data Structures
1. Arrays and Strings
   * Big-O Analysis
   * Code
     * Instantiation
     * Item Access
       * First
       * Last
     * Add Item(s)
       * Add one item
       * Add multiple items
     * Remove Item(s)
       * Remove one item
       * Remove multiple items
     * Find index
     * Iteration
       * Loop
       * forEach
       * for of
     * Slice
     * Reverse
     * Sort
     * Shallow Copy
     * Deep Copy
2. Linked List
   * Big-O Analysis
   * Code
     * Class Setup
     * Find
     * Insert
     * Delete
3. Binary Tree
   * Big-O Analysis
   * Code
     * Setup
     * Traversal
     * Pre-order
     * In-order
     * Post-order
     * Find
     * Insert
4. Stack
     * Big-O Analysis
     * Code
       * Setup
       * Push
       * Pop
       * Peek
       * Max
       * Empty?
5. Queue
   * Big-O Analysis
   * Code
     * Setup
     * Enqueue
     * Dequeue
     * Peek front
     * Peek back
     * Max
6. Hash Table (Object)
   * Big-O Analysis
   * Code
     * Setup
     * Insert
     * Delete
     * Keys
     * Values
     * Pairs
7. Binary Search Tree (Balanced Binary Tree)
   * Big-O Analysis
   * Code
     * Setup
     * Max
     * Min
     * Next Largest
     * Next Smallest
     * Find
     * Delete
8. Heap
   * Big-O Analysis
   * Code
     * Setup
     * Heapify
     * n-largest
     * n-smallest
     * push
     * pop
     * Return mix/max
9. Graphs
   * Big-O Analysis
   * Code
     * Setup
       * Adjacency Matrix
       * Adjacency List
10. Union Find
   * Big-O Analysis
   * Code   

### Algorithms
1. Binary Search
   * Big-O
   * Implementation
2. Merge Sort
   * Big-O
   * Implementation
3. Quick Sort
   * Big-O
   * Implementation
4. Depth-first Search
   * Big-O
   * Implementation
5. Breadth-first Search
   * Big-O
   * Implementation

### OOP
1. Inheritance (Object-based/Prototypal vs. Class-based)
2. Encapsulation
3. Polymorphism
4. Abstraction
5. Composition
6. Mixin
7. Instance vs. Class Variables/Methods

### Testing
1. Unit Tests
2. Integration Tests
3. End-to-end Tests
4. TDD (RGR)

### Paradigms (Identify Canonical Problems)
1. Divide and Conquer (Recursion)
2. Randomized Algorithms
3. Greedy Algorithms
4. Dynamic Programming
5. Brute Force

# Miscellaneous
### Math and Probability
1. Logarithms
2. Complex Number Representation

### Parallel Computing
1. Multi-core processors vs. single core
2. Parallelism vs. Concurrency
3. Amdahl's Law
4. Gustafson's Law

### Networking
1. OSI vs TCP/IP
2. Application Layer
3. Transport Layer
4. Network Layer
5. Link Layer
6. IP
7. TCP vs UDP
8. IPv4/IPv6 Address Assignment
9. ARP
10. ICMP
11. End-to-end Principle
12. Three Error Detection Algorithms
13. Packet
14. Packet Switching
15. Forwarding Table
16. Ethernet Switch vs. Internet Router
17. NATs and the New Hourglass
18. HTTP
19. DNS Architecture
20. DHCP
21. Internet Routing Protocols
22. Internet Structure
23. Shannon Capacity, Shannon Limit
24. Modulation
25. Signal to Noise Ratio (SNR)
26. Coding (list a few algorithms)
27. Why is data transmitted using a clock?
28. What are Asynchronous communications?
29. What are Synchronous communications?
30. How is the radio spectrum allocated in the US (that big map)?
31. How does Signal Strength work with wireless?
32. Ethernet, Ethernet most commonly used wired network
33. Ethernet Hubs vs. Switches
34. The fundamental network security problem
35. Three Ways Communication Can Be Compromised
36. Three Security Principles
37. The most important network security lesson
38. Wireless Communication: Digital vs. Analog
39. Wired Communication: Sync Serial vs. Async Serial vs. Parallel
40. UART

### Operating Systems
1. Operating System Definition
1. Kernel
2. What happens when a program runs? (Von Neumann)
3. CPU Virtualization
4. Memory Virtualization
5. Concurrency
6. Process
7. Threads
8. Persistence
9. 3 OS Abstractions
10. System Call
11. Trap
12. Context Switching
13. Caches (Single-CPU vs. Multi-CPU Hardware)
14. Address Space Components (Program Code, Stack, Heap)
15. Memory Problems (Leak, Stack Overflow, Segmentation Fault, Page Fault etc.)
16. Internal vs. External Fragmentation
17. Paging
18. Two Types of Locality
19. Single threaded process vs. Multi-threaded process
20. Context Switching between threads
21. Race condition, critical section, atomicity, transaction
22. Multi-threading Data Structures, Locks, Condition Variables, Mutexes, Semaphore
23. Famous Concurrency Problems: bounded buffer, dining philosophers, etc.
24. Common problems with concurrency (Non-Deadlock, Deadlock, Order-Violation)
25. Event-Based Concurrency (e.g. Node.JS)
26. Blocking vs. Non-Blocking Interfaces (Event-based Concurrency)
27. What does a canonical device consist of?
28. Interrupt vs. Polling
29. Device Driver
30. Single HDD vs. RAIDs
31. What is the File System, Ideal file system, File System Mental Model
32. What is a File, Directory, Directory Tree
33. Hard link vs. Link
34. Inode vs Inumber
35. Crash-consistency Problem and solutions

### Unix Command Line
1. What is the shell?
2. What is Bash?
3. What is text?
4. What is the typical directory structure on a linux system?
5. What Exactly Are Commands?
6. What is I/O redirection?
7. What are pipelines?
8. What are PIDs?
9. What are startup files?
10. How can you modify the environment?
11. What is FTP?
12. What is SSH?
13. What Are Shell Scripts?

### Databases
1. ORM
2. SQL Definition
3. RDBMS
4. Relational vs Non Relational Databases
5. SQL Sub-languages
6. DB Normalization
7. SQL vs NoSQL
8. DB Index
9. Foreign Key vs Primary Key
10. Three Entity Relationship Types
11. Types of Joins in SQL

### Languages
1. Generations: Machine Code, Assembly Language, Procedural Languages
2. Dynamic vs. Static Languages
3. Compiled Languages vs. Interpreted Languages
4. C Integration
5. Garbage Collection
6. Static vs. Dynamic Typing
7. Higher Order Functions & Lexical Closures
8. Pointer Arithmetic
9. Interpreter vs. Compiler
10. Java vs. JavaScript

### Computer Hardware
1. Boolean Logic (Nand Gate, Adder)
2. VHDL
3. Sequential Logic (Flip-flop, Register, Counter)
4. Memory (RAM, ROM, Firmware)
5. I/O
6. CPU (ALU, Data/Address Registers, Control Unit, Cache, Program Counter)
7. Fetch Execution Cycle
8. The Stored Program Concept
9. Von Neumann vs. Harvard (Data Memory, Instruction Memory)
10. Computer System (Memory, CPU, I/O)
11. RISC Pipeline (vs. CISC)
12. Moore's Law
13. Locality (Memory Access Hierarchy)
14. Numbers Everyone Should Know (latency)
15. Micro-controller vs Microprocessor
16. Multicore Processor

### Electronics
1. Electrical Current
2. Conventional vs. Actual Current Flow
3. Voltage
4. Resistance vs Resistivity
5. Conductivity
6. Heat vs. Power
7. Grounds
8. Current Divider (AC/DC)
9. Voltage Divider (AC/DC)
10. AC generation
11. AC importance
12. RMS vs. Peak-to-peak
13. Capacitors
14. Inductors
15. Complex Resistance, Capacitive Reactance, Inductive Reactance
16. Ohms Law's Law (AC/DC)
17. Apparent Power vs. Reactive Power vs. Real Power
18. Power Factor
19. Resonant Circuits
20. Two-port networks and filters
21. Phasor Diagram
22. Impedance (Resistors, Capacitors, Inductors)
23. Maxwell's Equations
24. Types of Motors
25. Transformer Applications
26. Electricity Distribution
27. Oscillator Circuits (Harmonic)
   * RC
   * LC
   * Crystal
28. Sensors
29. Electronic Switches
   * Vacuum Tubes
   * Relays
   * Transistors

### Design Patterns https://scotch.io/bar-talk/4-javascript-design-patterns-you-should-know
1. Module
2. Prototype
3. Observer
4. Singleton

### Misc CS
1. Scalability and Memory Limits
2. Operations/second
3. Words in Main Memory
4. Touch all words in 1 second
5. Operation Nanoseconds
6. Why 2s Comp is Used
7. P vs NP (Reductions)
8. P vs NP (Completeness)
9. P = NP if...
10. 3 strategies for NP-complete problems
11. Cryptography
12. Private/Public Key Cryptography
13. Diffie-Hellman Key Exchange
14. RSA Encryption

### Callbacks (JavaScript)
1. Callbacks
2. Promises
3. Async/Await
